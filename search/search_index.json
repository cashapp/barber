{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Barber\ud83d\udc88","text":"<p>A type safe Kotlin JVM library for building up localized, fillable, themed documents using Mustache templating.</p>"},{"location":"#press","title":"Press","text":"<ul> <li>Meet Barber\ud83d\udc88: the best way to manage your Mustache</li> </ul>"},{"location":"#why","title":"Why?","text":"<p>An application will often have hundreds of user viewable strings to power UI, notifications, emails, and other text based user interactions.</p> <p>This leads to many questions about the how to achieve the desired functionality of these user viewable strings:</p> <ul> <li>These strings may want to be personalizable! Thus the string would now have to be a template that can render with a data blob unique to each user to produce a personalized string.</li> <li>How can we check that the fillable openings in templates have corresponding values in the data blob?</li> <li>How can templates and data blobs be validated at compile time to protect against runtime exceptions or user visible bugs?</li> <li>What if we want to pass around not just a single template string, but a collection of template strings for more complex documents?</li> <li>How could we support emails that have a subject, body, recipient, primary button\u2026?</li> <li>What about different languages? <ul> <li>Could the same unique data blob be used to support templates in different languages?</li> </ul> </li> <li>What about time or money that differ between countries that even share the same language (ie. 12 vs 24 hour time)? </li> <li>How could that formatting localization be provided?</li> </ul> <p>To answer the above questions, we built Barber\ud83d\udc88. </p> <p>A type safe Kotlin JVM library for building up localized, fillable, themed documents using Mustache templating.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started using Barber, skim below to understand the different elements used to safely render your localized, fillable, themed documents using Mustache templating.</p>"},{"location":"#releases","title":"Releases","text":"<p>Our change log has release history. API is subject to change. </p> <p>Find the latest version on Maven Central.</p> <pre><code>implementation(\"app.cash.barber:barber:2024.01.12.173005-933c241\")\n</code></pre> <p>Releases are done automatically in CI upon merge to master branch.</p>"},{"location":"#documentdata","title":"DocumentData","text":"<p>DocumentData is the data that is used to render a template. In Barber, this is defined as a data class making it easy to use in Kotlin. </p> <pre><code>// Define DocumentData\ndata class RecipientReceipt(\n  val sender: String,\n  val amount: String,\n  val cancelUrl: String,\n  val deposit_expected_at: Instant\n) : DocumentData\n</code></pre> <p>To render a template, for example <code>\"{{sender}} sent you {{amount}}\"</code>, an instance of the above DocumentData could be passed in to fill the fillable openings in the template.</p>"},{"location":"#document","title":"Document","text":"<p>The final fields of the output, rendered document. </p> <p>For simple documents, this may be a single field.</p> <pre><code>// Define Document\ndata class TransactionalSmsDocument(\n  val sms_body: String\n) : Document\n</code></pre> <p>For more complex documents that may be used in further processing, there may be multiple fields, which can be nullable.</p> <pre><code>data class TransactionalEmailDocument(\n  val subject: String,\n  val headline: String,\n  val short_description: String,\n  val primary_button: String?,\n  val primary_button_url: String?,\n  val secondary_button: String?,\n  val secondary_button_url: String?\n) : Document\n</code></pre>"},{"location":"#documenttemplate","title":"DocumentTemplate","text":"<p>A DocumentTemplate is the glue that connects the DocumentData to the Document. It contains: - fields:      - keys fulfill all the non-nullable keys of the <code>Document</code> targets     - values are Mustache templates that are rendered with the passed in source <code>DocumentData</code> - source: <code>DocumentData</code> that can support all fillable templates in fields  - targets: <code>Document</code>s that the DocumentTemplate can render to  - locale: Locale for the language of the fields templates</p> <pre><code>val recipientReceiptSmsDocumentTemplateEN_US = DocumentTemplate(\n  fields = mapOf(\n    \"sms_body\" to \"{{sender}} sent you {{amount}}\"\n  ),\n  source = RecipientReceipt::class,\n  targets = setOf(TransactionalSmsDocument::class),\n  locale = Locale.EN_US\n)\n</code></pre>"},{"location":"#barber_1","title":"Barber <p>A Barber is typed to the <code>DocumentData -&gt; Document</code> relationship that it knows how to render.</p>  <p>Amy knows how to cut blonde hair into a Fu Manchu mustache. Joe knows how to trim brown hair into a soul patch mustache.</p>  <pre><code>// A Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument\nval recipientReceiptSms: Barber&lt;RecipientReceipt, TransactionalSmsDocument&gt;\n</code></pre>","text":""},{"location":"#barbershop","title":"Barbershop <p>A Barbershop contains all possible Barbers based on the installed <code>DocumentData</code>, <code>DocumentTemplate</code>, and <code>Document</code>s. </p> <p>Each Barber knows how to handle a different combination of <code>DocumentData -&gt; Document</code>.</p> <p>You can call <code>barbershop.getBarber&lt;RecipientReceipt, TransactionalSmsDocument&gt;()</code> to get the Barber that can handle rendering a <code>RecipientReceipt</code> into a <code>TransactionalSmsDocument</code>.</p> <pre><code>// Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument\nval recipientReceiptSms = barbershop.getBarber&lt;RecipientReceipt, TransactionalSmsDocument&gt;()\n</code></pre>  <p>You want a soul patch and have brown hair, get Joe! You want a Fu Manchu and have blonde hair, get Amy!</p>  <p>You can also get a Map of all Barbers using <code>barbershop.getAllBarbers()</code>.</p> <pre><code>// Get all Barbers\nval allBarbers: Map&lt;BarberKey, Barber&lt;DocumentData, Document&gt;&gt; = barbershop.getAllBarbers()\n</code></pre> <p>Note: <code>BarberKey</code> is a data class that let\u2019s us lookup by both <code>DocumentData</code> and <code>Document</code>.</p>","text":""},{"location":"#barbershopbuilder","title":"BarbershopBuilder <p>A Java style Builder that installs all of the above Barber elements and returns a pre-compiled and validated Barbershop.</p> <ul> <li>Install <code>DocumentData</code> and <code>DocumentTemplate</code> pairs with <code>.installDocumentTemplate&lt;RecipientReceipt&gt;(recipientReceiptSmsDocumentTemplateEN_US)</code>.</li> <li>Install <code>Document</code> with <code>.installDocument&lt;TransactionalSmsDocument&gt;()</code></li> <li>Optionally set a custom <code>LocaleResolver</code> with <code>.setLocaleResolver(MapleSyrupOrFirstLocaleResolver())</code></li> <li>Optionally set a default <code>BarberFieldEncoding</code> for non-annotated Document fields with <code>.setDefaultBarberFieldEncoding(STRING_PLAINTEXT)</code></li> <li>Optionally configure warning validation strictness with <code>.setWarningsAsErrors()</code></li> <li>Return the finished Barbershop with <code>.build()</code> as the final method call on BarbershopBuilder.</li> </ul> <pre><code>val barbershop = BarbershopBuilder()\n  .installDocumentTemplate&lt;RecipientReceipt&gt;(recipientReceiptSmsDocumentTemplateEN_US)\n  .installDocument&lt;TransactionalSmsDocument&gt;()\n  .build()\n</code></pre>","text":""},{"location":"#barberrenderdata-documentdata-locale-locale","title":"Barber.render(data: DocumentData, locale: Locale) <p>To render the final <code>Document</code>, a Barber requires a <code>DocumentData</code>,  used to fill the <code>DocumentTemplate</code>, and an output Locale.</p> <p>First, the Barber uses a <code>LocaleResolver</code> to find the best Locale match from installed <code>DocumentTemplate</code>s.</p> <p>Then, using the Locale resolved <code>DocumentTemplate</code>, Barber renders the fields of <code>DocumentTemplate</code> using the passed in <code>DocumentData</code>.</p> <p>Returned is the requested <code>Document</code> rendered with the personalized values of <code>DocumentData</code> in the closest match to the requested Locale.</p> <pre><code>// Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument\nval recipientReceiptSms = barbershop.getBarber&lt;RecipientReceipt, TransactionalSmsDocument&gt;()\n\n// Create the RecipientReceipt instance that holds the personalized data\nval sandy50Receipt = RecipientReceipt(\n  sender = \"Sandy Winchester\",\n  amount = \"$50\",\n  cancelUrl = \"https://cash.app/cancel/123\",\n  deposit_expected_at = Instant.parse(\"2019-05-21T16:02:00.00Z\")\n)\n\n// Render the final document using the personalized DocumentData instance and the output Locale\nval renderedSms = recipientReceiptSms.render(sandy50Receipt, EN_US)\n</code></pre>","text":""},{"location":"#barberfield-barberfieldencoding-and-html-character-escaping","title":"@BarberField, BarberFieldEncoding, and HTML Character Escaping <p>The <code>@BarberField</code> annotation can be used on Document class <code>val</code> fields to declare that the field should be rendered and treated according to a specific <code>BarberFieldEncoding</code>.</p> <p><code>BarberFieldEncoding</code> can be for now <code>STRING_HTML</code> or <code>STRING_PLAINTEXT</code>. </p> <p>By default, all fields are treated as <code>STRING_HTML</code> and have common HTML escaping of characters for safety. </p> <p>When a field is annotated as <code>STRING_PLAINTEXT</code>, characters will not be escaped.</p> <pre><code>data class EncodingTestDocument(\n  val no_annotation_field: String,\n  @BarberField()\n  val default_field: String,\n  @BarberField(encoding = BarberFieldEncoding.STRING_HTML)\n  val html_field: String,\n  @BarberField(encoding = BarberFieldEncoding.STRING_PLAINTEXT)\n  val plaintext_field: String\n) : Document\n\n// Rendered with all fields set to `You purchased 100 shares of McDonald's.`\nEncodingTestDocument(\n    no_annotation_field = \"You purchased 100 shares of McDonald&amp;#39;s.\",\n    default_field = \"You purchased 100 shares of McDonald&amp;#39;s.\",\n    html_field = \"You purchased 100 shares of McDonald&amp;#39;s.\",\n    // Note: no character escaping on the plaintext field\n    plaintext_field = \"You purchased 100 shares of McDonald's.\"\n)\n</code></pre>","text":""},{"location":"#locale","title":"Locale <p>Barber supports installation and resolution of multiple Locales for each <code>DocumentTemplate</code>.</p> <p>All Locale versions of a DocumentTemplate will be installed with the BarbershopBuilder.</p> <p>The desired output Locale is then provided at render time and the best available option is resolved.</p> <pre><code>// Define DocumentTemplate in English\nval recipientReceiptSmsDocumentTemplateEN_US = DocumentTemplate(\n  fields = mapOf(\"sms_body\" to \"{{sender}} sent you {{amount}}\"),\n  source = RecipientReceipt::class,\n  targets = setOf(TransactionalSmsDocument::class),\n  locale = Locale.EN_US\n)\n\n// Define DocumentTemplate in Canadian English\nval recipientReceiptSmsDocumentTemplateEN_CA = DocumentTemplate(\n  fields = mapOf(\"sms_body\" to \"{{sender}} sent you {{amount}}, eh!\"),\n  // ... same as EN_US\n  locale = Locale.EN_CA\n)\n\n// Define DocumentTemplate in Spanish\nval recipientReceiptSmsDocumentTemplateES_US = DocumentTemplate(\n  fields = mapOf(\"sms_body\" to \"{{sender}} te envi\u00f3 {{amount}}\"),\n  // ... same as EN_US\n  locale = Locale.ES_US\n)\n\n// Use above elements to build a Barbershop \nval barbershop = BarbershopBuilder()\n  .installDocumentTemplate&lt;RecipientReceipt&gt;(recipientReceiptSmsDocumentTemplateEN_US)\n  .installDocumentTemplate&lt;RecipientReceipt&gt;(recipientReceiptSmsDocumentTemplateEN_CA)\n  .installDocumentTemplate&lt;RecipientReceipt&gt;(recipientReceiptSmsDocumentTemplateES_US)\n  .installDocument&lt;TransactionalSmsDocument&gt;()\n  .build()\n\n// Get a Barber who knows how to render RecipientReceipt data into a TransactionalSmsDocument\nval recipientReceiptSms = barbershop.getBarber&lt;RecipientReceipt, TransactionalSmsDocument&gt;()\n\n// Render in each Locale\nval smsEN_US = recipientReceiptSms.render(sandy50Receipt, EN_US) // = Sandy Winchester sent you $50\nval smsEN_CA = recipientReceiptSms.render(sandy50Receipt, EN_CA) // = Sandy Winchester sent you $50, eh?\nval smsES_US = recipientReceiptSms.render(sandy50Receipt, ES_US) // = Sandy Winchester te envio $50\n</code></pre>","text":""},{"location":"#localeresolver","title":"LocaleResolver","text":"<p>Determining based on a Locale passed in at render which installed Locale to render is done by a LocaleResolver.</p> <p>It is a simple interface that looks like this:</p> <pre><code>abstract class LocaleResolver {\n  /**\n   * @return a [Locale] from the given [options]\n   * @param [options] must be valid keys for a Locale keyed Map\n   */\n  fun resolve(locale: Locale, options: Set&lt;Locale&gt;): Locale\n}\n</code></pre> <p>Barber comes with a very simple <code>MatchOrFirstLocaleResolver</code> that attempts to resolve the requested Locale exactly, and otherwise chooses the first installed Locale.</p> <p>For more complex resolution algorithms, you can set your own custom <code>LocaleResolver</code> when building your Barbershop.</p> <pre><code>val barbershop = BarbershopBuilder()\n  // ...\n  .setLocaleResolver(MapleSyrupOrFirstLocaleResolver) // Always tries to resolve EN_CA\n  .build()\n</code></pre>"},{"location":"#version-compatibility-resolution","title":"Version Compatibility &amp; Resolution","text":"<p>Barber supports installation of multiple versions of the same template. When Barber is used in a service that stores in a database versioned templates, the following capabilities drastically improve the safety, reliability, and functionality of rendering versioned templates.</p> <p>For example, Barber can handle variable additions, subtractions, and changes between versions. For example, if a template has a new variable added, the corresponding DocumentData class will also have a new field.</p> <pre><code>// git diff of the new version of the DocumentData\ndata class RecipientReceipt(\n  val sender: String,\n  val amount: String,\n+  val recipient: String,\n) : DocumentData\n</code></pre> <p>Assuming a microservice environment where old clients could exist sending the old DocumentData missing the new field, Barber does the right thing and falls back to the newest, compatible template to render.</p> <p>Compatibility in this case refers to ensuring that the signature (variables and types) of the DocumentData provided can fulfill the chosen template.</p> <p>By default, Barber chooses the newest compatible version, or throws an exception if a version is explicitly provided that does not exist or is incompatible.</p> <p>For more complex resolution algorithms, you can set your own custom <code>VersionResolver</code> when building your Barbershop.</p> <pre><code>val barbershop = BarbershopBuilder()\n  // ...\n  .setVersionResolver(SpecifiedOrNewestCompatibleVersionResolver) // Always returns newest compatible version, ignores explicitly provided version\n  .build()\n</code></pre>"},{"location":"#integration-with-guice","title":"Integration with Guice","text":"<p>If you use Guice, creating a module that automatically binds all possible typed Barber instances is simple. See the code example below.</p> <pre><code>package com.your.service.package\n\nimport com.google.inject.AbstractModule\nimport com.google.inject.Key\nimport com.google.inject.util.Types\nimport app.cash.barber.Barber\nimport app.cash.barber.Barbershop\nimport app.cash.barber.models.BarberKey\nimport app.cash.barber.models.Document\nimport app.cash.barber.models.DocumentData\n\n/**\n * Binds all the barbers so they may be injected directly like so:\n *\n * ```\n * @Inject var barber: Barber&lt;RecipientReceipt, TransactionalSmsDocument&gt;\n * ```\n */\nclass BarberModule(private val barbershop: Barbershop) : AbstractModule() {\n  override fun configure() {\n    barbershop.getAllBarbers().forEach { (barberKey, barber) -&gt;\n      bind(barberKey.asGuiceKey()).toInstance(barber)\n    }\n  }\n\n  private fun BarberKey.asGuiceKey(): Key&lt;Barber&lt;DocumentData, Document&gt;&gt; {\n    val barberType = Types.newParameterizedType(Barber::class.java, documentData.java, document.java)\n    @Suppress(\"UNCHECKED_CAST\") // We know this cast is safe dynamically.\n    return Key.get(barberType) as Key&lt;Barber&lt;DocumentData, Document&gt;&gt;\n  }\n}\n</code></pre>"},{"location":"#coming-soon","title":"Coming Soon","text":""},{"location":"#fieldstemming","title":"FieldStemming","text":"<p>Automatically replace Money, DateTime, and Instant types with BarberMoney, BarberDateTime, and BarberInstant that let templates call out localized formatted output of each type.</p> <p>Example</p> <pre><code>BarberInstant(Instant(2019-05-15T15:23:11), EN_US)\n= mapOf(\n    \"date\" to \"May 15, 2019\", \n    \"time\" to \"3:23 pm\",\n    \"casual\" to \"tomorrow at 3pm\"\n )\n\nBarberMoney(Money(50_00), EN_US)\n= mapOf(\n    \"full\" to \"$50.00\"\n    \"casual\" to \"$50\"\n )\n</code></pre>"},{"location":"#license","title":"License <pre><code>Copyright 2019 Square, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>","text":""},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#version-032","title":"Version 0.3.2","text":"<p>2020-10-21</p> <ul> <li>Include Protos in Jar</li> </ul>"},{"location":"changelog/#version-031","title":"Version 0.3.1","text":"<p>2020-10-21</p> <ul> <li>Render null DocumentData field as empty string, not as \u201cnull\u201d</li> </ul>"},{"location":"changelog/#version-030","title":"Version 0.3.0","text":"<p>2020-10-21</p> <ul> <li>Default to String when Proto DocumentData has a null field with ambiguous type</li> </ul>"},{"location":"changelog/#version-020","title":"Version 0.2.0","text":"<p>2020-10-21</p> <ul> <li>New support for dynamic document data and templates using Protos</li> </ul>"},{"location":"changelog/#version-010","title":"Version 0.1.0","text":"<p>2019-07-16</p> <ul> <li>Initial release.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request.</p> <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.</p> <p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>"}]}